/**
 * Planning Storage React Hook
 *
 * ëª©ì : ì´ì¤‘ ì €ì¥ ì‹œìŠ¤í…œì˜ React ì¸í„°í˜ì´ìŠ¤ ì œê³µ
 * ì±…ì„: Redux ìƒíƒœ ì—°ê²°, ì•¡ì…˜ ë””ìŠ¤íŒ¨ì¹˜, íƒ€ì… ì•ˆì „ì„±
 */

import { useCallback, useMemo } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import type { AppDispatch, RootState } from '@/shared/store';
import {
  submitDualStorage,
  retryFailedStorage,
  resetStorageState,
  clearLastError,
  resetMetrics,
} from '../model/planning-storage.slice';
import type {
  StorageRequest,
  DualStorageResult,
  UsePlanningStorageReturn,
  METRICS_THRESHOLDS,
} from '../types/planning-storage.types';

// ============================================================================
// ë©”ì¸ Hook
// ============================================================================

/**
 * Planning Storage Hook
 *
 * ì´ì¤‘ ì €ì¥ ì‹œìŠ¤í…œê³¼ ìƒí˜¸ì‘ìš©í•˜ê¸° ìœ„í•œ í†µí•© ì¸í„°í˜ì´ìŠ¤
 */
export function usePlanningStorage(): UsePlanningStorageReturn {
  const dispatch = useDispatch<AppDispatch>();

  // Redux ìƒíƒœ ì„ íƒ
  const state = useSelector((state: RootState) => state.planningStorage);

  // ========================================================================
  // íŒŒìƒ ìƒíƒœ ê³„ì‚°
  // ========================================================================

  const derivedState = useMemo(() => ({
    isLoading: state.status === 'loading',
    hasError: state.status === 'error' || state.lastError !== null,
    recentResults: state.results.successful.slice(-10), // ìµœê·¼ 10ê°œ
    retryQueueSize: state.retryQueue.length,
  }), [state.status, state.lastError, state.results.successful, state.retryQueue.length]);

  // ========================================================================
  // ì•¡ì…˜ í•¨ìˆ˜ë“¤
  // ========================================================================

  /**
   * ì´ì¤‘ ì €ì¥ ìš”ì²­ ì œì¶œ
   */
  const submitStorage = useCallback(async (request: StorageRequest): Promise<DualStorageResult> => {
    console.log('ğŸš€ Hook: ì´ì¤‘ ì €ì¥ ìš”ì²­ ì‹œì‘', {
      type: request.type,
      projectId: request.projectId,
    });

    try {
      const result = await dispatch(submitDualStorage(request)).unwrap();

      console.log('âœ… Hook: ì´ì¤‘ ì €ì¥ ì„±ê³µ', {
        projectId: request.projectId,
        latency: result.latencyMs,
        prismaStored: result.prismaResult.saved,
        supabaseStored: result.supabaseResult.saved,
      });

      return result;
    } catch (error) {
      console.error('âŒ Hook: ì´ì¤‘ ì €ì¥ ì‹¤íŒ¨', {
        projectId: request.projectId,
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  }, [dispatch]);

  /**
   * ì‹¤íŒ¨í•œ ìš”ì²­ë“¤ ì¬ì‹œë„
   */
  const retryFailed = useCallback(async (): Promise<void> => {
    if (state.retryQueue.length === 0) {
      console.warn('âš ï¸ Hook: ì¬ì‹œë„í•  ìš”ì²­ì´ ì—†ìŠµë‹ˆë‹¤');
      return;
    }

    console.log(`ğŸ”„ Hook: ${state.retryQueue.length}ê°œ ìš”ì²­ ì¬ì‹œë„ ì‹œì‘`);

    try {
      const results = await dispatch(retryFailedStorage()).unwrap();

      console.log('âœ… Hook: ì¬ì‹œë„ ì™„ë£Œ', {
        successCount: results.length,
        originalQueueSize: state.retryQueue.length,
      });
    } catch (error) {
      console.error('âŒ Hook: ì¬ì‹œë„ ì‹¤íŒ¨', error);
      throw error;
    }
  }, [dispatch, state.retryQueue.length]);

  /**
   * ì—ëŸ¬ ìƒíƒœ ì§€ìš°ê¸°
   */
  const clearError = useCallback(() => {
    dispatch(clearLastError());
  }, [dispatch]);

  /**
   * ì „ì²´ ìƒíƒœ ì´ˆê¸°í™”
   */
  const resetState = useCallback(() => {
    dispatch(resetStorageState());
  }, [dispatch]);

  /**
   * ë©”íŠ¸ë¦­ ì´ˆê¸°í™”
   */
  const resetStorageMetrics = useCallback(() => {
    dispatch(resetMetrics());
  }, [dispatch]);

  // ========================================================================
  // ë°˜í™˜ ê°ì²´ êµ¬ì„±
  // ========================================================================

  return {
    // ìƒíƒœ
    status: state.status,
    isLoading: derivedState.isLoading,
    hasError: derivedState.hasError,

    // ë°ì´í„°
    metrics: state.metrics,
    recentResults: derivedState.recentResults,
    failedRequests: state.results.failed,
    retryQueueSize: derivedState.retryQueueSize,

    // ì•¡ì…˜
    submitStorage,
    retryFailed,
    clearError,
    resetState,
    resetMetrics: resetStorageMetrics,
  };
}

// ============================================================================
// íŠ¹í™”ëœ Hookë“¤
// ============================================================================

/**
 * íŠ¹ì • í”„ë¡œì íŠ¸ì˜ ì €ì¥ ìƒíƒœë§Œ ì¶”ì í•˜ëŠ” Hook
 */
export function useProjectStorageStatus(projectId: string) {
  const { recentResults, failedRequests } = usePlanningStorage();

  return useMemo(() => {
    // ìµœê·¼ ì„±ê³µí•œ ì €ì¥ ì¤‘ì—ì„œ í•´ë‹¹ í”„ë¡œì íŠ¸ ì°¾ê¸°
    const successfulResult = recentResults.find(
      result => result.request?.projectId === projectId
    );

    // ì‹¤íŒ¨í•œ ì €ì¥ ì¤‘ì—ì„œ í•´ë‹¹ í”„ë¡œì íŠ¸ ì°¾ê¸°
    const failedResult = failedRequests.find(
      result => result.request.projectId === projectId
    );

    return {
      isStored: !!successfulResult,
      lastStoredAt: successfulResult?.timestamp,
      hasFailed: !!failedResult,
      lastError: failedResult?.error,
      needsRetry: !!failedResult,
    };
  }, [projectId, recentResults, failedRequests]);
}

/**
 * ì €ì¥ ì‹œìŠ¤í…œ ê±´ê°•ì„± ëª¨ë‹ˆí„°ë§ Hook
 */
export function useStorageHealthMonitor() {
  const { metrics } = usePlanningStorage();

  return useMemo(() => {
    const health = {
      overall: 'healthy' as 'healthy' | 'warning' | 'critical',
      issues: [] as string[],
      recommendations: [] as string[],
    };

    // ì„±ê³µë¥  ê²€ì‚¬
    if (metrics.successRate < METRICS_THRESHOLDS.SUCCESS_RATE_CRITICAL) {
      health.overall = 'critical';
      health.issues.push(`ì„±ê³µë¥ ì´ ë§¤ìš° ë‚®ìŠµë‹ˆë‹¤ (${metrics.successRate.toFixed(1)}%)`);
      health.recommendations.push('ì‹œìŠ¤í…œ ì ê²€ì´ í•„ìš”í•©ë‹ˆë‹¤');
    } else if (metrics.successRate < METRICS_THRESHOLDS.SUCCESS_RATE_WARNING) {
      if (health.overall === 'healthy') health.overall = 'warning';
      health.issues.push(`ì„±ê³µë¥ ì´ ë‚®ìŠµë‹ˆë‹¤ (${metrics.successRate.toFixed(1)}%)`);
      health.recommendations.push('ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”');
    }

    // ì‘ë‹µ ì‹œê°„ ê²€ì‚¬
    if (metrics.averageLatency > METRICS_THRESHOLDS.LATENCY_CRITICAL) {
      health.overall = 'critical';
      health.issues.push(`ì‘ë‹µ ì‹œê°„ì´ ë§¤ìš° ëŠë¦½ë‹ˆë‹¤ (${metrics.averageLatency.toFixed(0)}ms)`);
      health.recommendations.push('ì„œë²„ ì„±ëŠ¥ì„ ì ê²€í•˜ì„¸ìš”');
    } else if (metrics.averageLatency > METRICS_THRESHOLDS.LATENCY_WARNING) {
      if (health.overall === 'healthy') health.overall = 'warning';
      health.issues.push(`ì‘ë‹µ ì‹œê°„ì´ ëŠë¦½ë‹ˆë‹¤ (${metrics.averageLatency.toFixed(0)}ms)`);
      health.recommendations.push('ë„¤íŠ¸ì›Œí¬ ìµœì í™”ë¥¼ ê³ ë ¤í•˜ì„¸ìš”');
    }

    // ë¡¤ë°± íšŸìˆ˜ ê²€ì‚¬
    if (metrics.rollbackCount >= METRICS_THRESHOLDS.ROLLBACK_WARNING) {
      if (health.overall === 'healthy') health.overall = 'warning';
      health.issues.push(`ë¡¤ë°±ì´ ìì£¼ ë°œìƒí•©ë‹ˆë‹¤ (${metrics.rollbackCount}íšŒ)`);
      health.recommendations.push('Supabase ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”');
    }

    // Supabase ê°œë³„ ì„±ê³µë¥  ê²€ì‚¬
    if (metrics.supabaseSuccessRate < 80) {
      if (health.overall === 'healthy') health.overall = 'warning';
      health.issues.push(`Supabase ì €ì¥ ì‹¤íŒ¨ìœ¨ì´ ë†’ìŠµë‹ˆë‹¤ (${metrics.supabaseSuccessRate.toFixed(1)}%)`);
      health.recommendations.push('Supabase RLS ì •ì±…ê³¼ Service Role í‚¤ë¥¼ í™•ì¸í•˜ì„¸ìš”');
    }

    return health;
  }, [metrics]);
}

/**
 * íƒ€ì…ë³„ ì €ì¥ í†µê³„ë¥¼ ì œê³µí•˜ëŠ” Hook
 */
export function useStorageStatsByType() {
  const { recentResults, failedRequests } = usePlanningStorage();

  return useMemo(() => {
    const stats = {
      story: { successful: 0, failed: 0 },
      scenario: { successful: 0, failed: 0 },
      prompt: { successful: 0, failed: 0 },
      video: { successful: 0, failed: 0 },
    };

    // ì„±ê³µí•œ ì €ì¥ ì§‘ê³„
    recentResults.forEach(result => {
      if (result.request?.type && stats[result.request.type]) {
        stats[result.request.type].successful += 1;
      }
    });

    // ì‹¤íŒ¨í•œ ì €ì¥ ì§‘ê³„
    failedRequests.forEach(result => {
      if (result.request.type && stats[result.request.type]) {
        stats[result.request.type].failed += 1;
      }
    });

    // ê° íƒ€ì…ë³„ ì„±ê³µë¥  ê³„ì‚°
    const statsWithRates = Object.entries(stats).map(([type, data]) => {
      const total = data.successful + data.failed;
      const successRate = total > 0 ? (data.successful / total) * 100 : 100;

      return {
        type,
        ...data,
        total,
        successRate,
      };
    });

    return statsWithRates;
  }, [recentResults, failedRequests]);
}

// ============================================================================
// Export
// ============================================================================

export type { UsePlanningStorageReturn };