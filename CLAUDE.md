
# 최종 통합 개발지침
### 에이전트 활용 시 병렬 작업 진행 ###

## Ⅰ. 최상위 원칙: 개발 생명주기 (The Lifecycle)

**전제 원칙**  
- 모든 작업에는 **Plan → Do → See** 프레임워크를 적용하여 계획, 실행, 피드백의 선순환 구조를 유지합니다.  
- 분석 단계에서는 반드시 **MECE**(Mutually Exclusive, Collectively Exhaustive) 원칙을 적용하여 중복 없이, 빠짐없이 정리합니다.
- 서브 에이전트 활용 시 병렬 방식으로 진행
- 모든 개발은 중복 파일 생성하지 않고, **통합형**으로 개발 진행.

모든 개발 작업은 반드시 이 순환적(Cyclical) 워크플로우를 따라야 합니다. 이는 작업의 시작과 끝을 명확히 하여, 모든 행동이 과거의 맥락에 기반하고 미래의 자산으로 축적되게 합니다.

### 1. (Alpha) 작업 착수: 컨텍스트 로드
**역할 분담**  
- **팀 리드(분석·전략·계획)**: 전체 작업 목표를 분석하고, 우선순위를 정하며, 전략과 액션플랜(세부 계획)을 수립합니다.  
- **팀원(실행)**: 팀 리드가 수립한 계획과 명령을 하달받아, 각자 맡은 업무를 직접 병렬로 해결하고 결과를 보고합니다.

**절대 원칙**  
어떠한 개발 작업도 시작하기 전, 반드시 MEMORY.MD 파일을 열어 모든 과거 대화 기록과 결정 사항을 로드합니다.

MEMORY.md 파일의 내용을 변경 및 삭제 금지.
추가 기록만 진행할 것.

**[AI 실행 방안]**  
작업 요청을 받으면, 저는 가장 먼저 MEMORY.MD를 전체 스캔하여 관련 맥락을 파악하고,  
"지난번에 논의했던 'X' 정책에 따라 이 작업을 진행하겠습니다. 맞습니까?" 와 같이 과거 맥락을 기반으로 작업 계획을 확인합니다.

**Claude Code 활용 지침**
- **명확한 사양서 작성**: 프로젝트 시작 전 요구사항과 맥락을 명확히 문서화해 Claude Code 에이전트에게 제공하여 코드 작성 방향과 범위를 분명히 함.
- **프로젝트 구조 문서화**: 빌드, 린트, 테스트 실행 방법을 포함한 문서를 마련하여 Claude Code가 코드베이스를 더 효과적으로 탐색하고 작업 가능하도록 함.
- **개인 “글로벌” 에이전트 가이드 활용**: 문제 해결 접근, TDD 적용, 단순성·명확성 유지, 시도 횟수 제한(3회) 등 개인 규칙을 담은 `~/.claude/CLAUDE.md`를 통해 일관된 개발 프로세스 유지.

---

### 2. 테스트 구현 전략
코어 로직 (지능형 TDD): 요구사항 분석 후, 실패하는 테스트 코드를 먼저 생성하여 제시합니다.  
UI (자동화된 BDD): UI 컴포넌트 구현 직후, 핵심 동작 시나리오를 담은 테스트 코드 초안을 자동으로 생성합니다.

**Claude Code 활용 지침**
- Claude Code에게 테스트 코드 생성을 요청하되, 작성자는 모든 코드를 수동으로 검토하고 누락된 테스트 케이스를 직접 추가하거나 AI에 작성 요청 후 코드·테스트를 다시 검토.
- 작성된 테스트는 반드시 **결정론적**이며, 기존 테스트 유틸리티를 재사용하고 프로젝트 패턴과 일관성을 유지해야 함.

---

### 3. 기능 구현 및 수정
모든 개발 철학(Ⅱ), 실행 가이드(Ⅲ), 팀 문화(Ⅳ)를 준수하여 코드를 작성합니다.

**Claude Code 활용 지침**
- **에이전트 코드 리뷰 요청**: Claude Code에게 생성한 코드를 직접 리뷰하게 하여 예상치 못한 개선점이나 버그를 발견.
- **최종 품질 책임 명확화**: PR에 자신의 이름이 들어가는 이상, 최종 품질 책임은 본인에게 있음을 명심하고 직접 코드 품질을 검증.

---

### 4. (Omega) 작업 종료: 컨텍스트 기록
**절대 원칙**  
작업 완료 후 커밋하기 직전, 반드시 MEMORY.MD 파일을 열어 대화 내용과 작업 결과를 기록합니다.

**[AI 실행 방안]**  
작업이 완료되면, 저는 [날짜/시간], [요청 내용], [핵심 해결책], [주요 결정사항 및 근거] 형식으로 자동 요약된 기록을 제시하고, 사용자 확인 후 MEMORY.MD에 추가합니다.  
"오늘 작업을 MEMORY.MD에 다음과 같이 기록하겠습니다. 수정할 부분이 있나요?"

**Claude Code 활용 지침**
- 작업 종료 시 Claude Code를 통해 변경사항, 품질 게이트(모든 테스트 통과, 린터 경고 없음, 계획과의 일치 여부) 점검.
- **코드 리뷰 기록 자동화**: PR 병합 시 Claude Code가 주요 변경점, 리뷰 내용, 승인 사유를 자동 요약하여 `MEMORY.MD`와 `CHANGELOG.md`에 기록.
- **실패 시 재시도 로그 분석**: 3회 시도 제한에 걸리거나 빌드/테스트가 반복 실패할 경우, Claude Code에게 실패 로그를 요약 분석시켜 다음 시도 전략 제안.

---

### 5. 커밋 및 종료
docs/checklist.md 업데이트를 포함하여, 모든 변경사항을 하나의 논리적 단위로 커밋합니다.  
커밋 전에는 포매터·린터 실행, 테스트 통과, 셀프 리뷰를 반드시 거칩니다.

**추가 단계**
- **보안 점검 단계**: PR 전 AI 기반 보안 스캐너를 실행하여 취약점을 자동 리포트하고, 결과를 PR 검토 항목에 포함.

---

## Ⅱ. 핵심 철학: 의사결정 기준 (The Philosophy)
AI 개발자가 코드 생성 및 문제 해결 시 최우선으로 고려하는 내장된 사고 모델입니다.

### 1. 본질적 문제 해결
절대 원칙: "A방법이 위험하다면, 시간이 더 걸려도 안전한 B방법으로 해결한다."

**[AI 실행 방안]**  
코드 수정 요청 시, 잠재적 영향 범위를 먼저 분석하여 보고하고, 버그 발생 시 '5 Whys' 분석 리포트를 자동으로 제시하여 근본 원인을 명확히 합니다.

**Claude Code 활용 지침**
- AI 생성 코드를 채택하기 전 반드시 수동 검토를 거쳐 근본 원인 분석과 리스크 평가 후 결정.

---

### 2. 초고성능 자동화
성과 목표: 단순 작동을 넘어, 사용자 작업을 10배 이상 효율화하는 것을 목표로 합니다.

**[AI 실행 방안]**  
주어진 작업뿐만 아니라, 코드 변경 이력과 패턴을 학습하여 새로운 자동화 기회를 먼저 제안합니다.

**Claude Code 활용 지침**
- 반복적인 코드나 패턴은 Claude Code를 활용하여 자동화 방안을 제안받고, 모듈화·재사용성을 극대화.

---

## 개인 “글로벌” 에이전트 가이드 주요 내용
해당 가이드는 `~/.claude/CLAUDE.md` 파일로 관리함.

### 철학과 핵심 원칙
- 점진적 진행: 작은 단위로 변경, 항상 컴파일과 테스트 통과
- 기존 코드 학습: 구현 전 코드 패턴 분석 및 계획 수립
- 실용성 우선: 프로젝트 상황에 맞춘 유연한 접근
- 명확성 우선: 읽기 쉽고 의도가 분명한 코드, 불필요한 트릭 회피

### 단순성 정의
- 함수·클래스는 단일 책임
- 조기 추상화 지양
- 복잡성 줄이고 설명 필요 없는 코드 지향

### 작업 프로세스
1. 기획 및 단계 설정: 복잡한 작업은 3~5단계로 나눠 `IMPLEMENTATION_PLAN.md`에 기록. 단계별 목표, 성공 기준, 테스트 케이스, 진행 상태 명시
2. 구현 흐름: 이해 → 테스트 작성(빨강) → 최소 구현(초록) → 리팩토링 → 커밋
3. 3회 시도 제한 후 재평가: 실패 시 시도 내역과 오류, 원인 기록, 대안 탐색(2~3가지 접근), 근본적인 설계·문제 분해 재검토, 다른 패턴·기능 시도

### 기술 표준
- 구성(Composition) 우선, 의존성 주입 활용
- 인터페이스 사용, 테스트 용이성 확보
- 명시적 데이터 흐름
- TDD 권장, 테스트 비활성화 금지

### 코드 품질 규칙
- 모든 커밋은 컴파일 성공, 테스트 통과, 신규 기능 테스트 포함, 코드 스타일 준수
- 커밋 전 포매터·린터 실행, 변경사항 셀프 리뷰, "왜"를 설명하는 커밋 메시지 작성

### 오류 처리
- 빠른 실패와 구체적 메시지
- 디버깅에 필요한 컨텍스트 제공
- 적절한 레벨에서 예외 처리, 예외 은폐 금지

### 의사결정 기준
1. 테스트 용이성
2. 6개월 후에도 이해 가능한 가독성
3. 프로젝트 패턴과의 일관성
4. 단순함
5. 변경 용이성

### 프로젝트 통합
- 유사 기능 3개 이상 분석
- 기존 패턴·라이브러리 재사용
- 동일한 테스트 유틸리티 사용
- 새 도구 도입 시 강력한 이유 필요

### 품질 게이트
- 모든 테스트 통과
- 프로젝트 규칙 준수
- 린터 경고 없음
- 커밋 메시지 명확
- 구현이 계획과 일치
- TODO에 이슈 번호 포함

### 테스트 지침
- 구현이 아닌 동작 중심 테스트
- 가능하면 테스트당 하나의 단언
- 시나리오를 설명하는 명확한 이름
- 기존 테스트 유틸리티 재사용
- 테스트는 결정론적이어야 함

### 절대 금지
- --no-verify로 훅 우회
- 테스트 비활성화
- 컴파일 안 되는 코드 커밋
- 검증 없는 추측

### 반드시 수행
- 점진적 커밋
- 문서 지속 업데이트
- 기존 구현에서 학습
- 3회 실패


## Ⅴ. 프로젝트별 특수 지침 (Project-Specific Guidelines)

### 1. VideoPlanet 프로젝트 구조
- **프론트엔드**: React, next.js Vercel 배포
- **백엔드**: Django (Railway 배포)
- **데이터베이스**: PostgreSQL
- **캐시**: Redis

### 2. 배포 및 버전 관리
원칙: 모든 배포는 버전 태그와 함께, 상세한 로그 기록 필수.

[AI 실행 방안]: 
- 배포 전 체크리스트 자동 생성 및 확인
- package.json 버전 업데이트 자동 제안
- Git 태그 생성 명령어 제시
- 배포 후 헬스체크 URL 및 확인사항 제공

### 3. 마이그레이션 관리
절대 원칙: 모든 데이터베이스 변경은 마이그레이션을 통해서만 수행.

[AI 실행 방안]:
- 모델 변경 시 자동으로 마이그레이션 생성 명령어 제시
- 마이그레이션 파일 커밋 여부 체크
- 운영 환경 영향도 분석 자동 수행

### 4. UI/UX 디자인 일관성
원칙: 브랜드 색상 통일, 일관된 인터랙션 패턴.

주요 색상:
- 주요 액션 버튼: #1631F8 (그라데이션)
- 위험/취소 액션: #dc3545
- 성공 상태: #28a745
- 경고 상태: #ffc107
- 정보 상태: #17a2b8

[AI 실행 방안]: UI 컴포넌트 생성 시 자동으로 브랜드 가이드라인 준수 여부 체크 및 올바른 색상 코드 제안.

### 5. 에러 처리 표준
원칙: 사용자 친화적 에러 메시지, 개발자를 위한 상세 로그.

[AI 실행 방안]:
- try-catch 블록 생성 시 표준 에러 핸들링 패턴 자동 적용
- 에러 메시지 한국어 번역 자동 제공
- 로깅 레벨 자동 설정

## Ⅵ. 성능 최적화 지침

### 1. 프론트엔드 최적화
원칙: 초기 로딩 3초 이내, 인터랙션 응답 100ms 이내.

[AI 실행 방안]:
- React.memo, useMemo, useCallback 사용 제안
- 이미지 최적화 (lazy loading, WebP 포맷) 자동 적용
- 번들 크기 분석 및 코드 스플리팅 제안

### 2. 백엔드 최적화
원칙: API 응답 시간 200ms 이내, N+1 쿼리 방지.

[AI 실행 방안]:
- Django ORM 쿼리 최적화 (select_related, prefetch_related) 자동 제안
- Redis 캐싱 전략 자동 생성
- 인덱스 추가 필요성 자동 분석

## Ⅶ. 테스트 전략

### 1. 테스트 커버리지
목표: 핵심 비즈니스 로직 90% 이상, 전체 70% 이상.

[AI 실행 방안]:
- 새 기능 구현 시 테스트 코드 자동 생성
- 엣지 케이스 테스트 시나리오 자동 제안
- 테스트 실행 명령어 즉시 제공

### 2. E2E 테스트
원칙: 주요 사용자 시나리오는 반드시 E2E 테스트로 검증.

[AI 실행 방안]:
- Cypress/Playwright 테스트 스크립트 자동 생성
- 크로스 브라우저 테스트 필요성 판단

## Ⅷ. 모니터링 및 로깅

### 1. 로깅 표준
원칙: 구조화된 로그, 적절한 로그 레벨 사용.

[AI 실행 방안]:
- 로그 포맷 일관성 자동 체크
- 민감 정보 로깅 방지 자동 검사
- 로그 레벨 자동 설정 (DEBUG, INFO, WARNING, ERROR, CRITICAL)

### 2. 알림 설정
원칙: 중요 이벤트는 즉시 알림, 노이즈 최소화.

[AI 실행 방안]:
- 에러 임계값 자동 제안
- 알림 채널 설정 가이드 제공

## Ⅸ. 프로젝트 구조 관리 및 문서화

### 1. Memory.md 관리 원칙
원칙: 프로젝트 구조가 변경될 때마다 memory.md 최상단의 프로젝트 구조를 업데이트합니다.

[AI 실행 방안]:
- 새로운 파일/디렉토리 생성 시 memory.md 구조 업데이트 자동 제안
- 파일 이동/삭제 시 memory.md 구조 반영 확인
- 주요 기능 추가/변경 시 히스토리 섹션에 자동 기록

### 2. 프로젝트 구조 문서화 표준
필수 포함 사항:
- 전체 디렉토리 트리 구조
- 각 주요 디렉토리/파일의 용도 설명
- 기술 스택 및 버전 정보
- 주요 URL 및 엔드포인트

[AI 실행 방안]:
- 프로젝트 구조 변경 감지 시 "memory.md 업데이트가 필요합니다" 알림
- 구조 변경사항을 자동으로 파악하여 업데이트 제안
- 커밋 전 memory.md 업데이트 여부 체크리스트 제공

## Ⅹ. 스타일 파일 관리 및 CSS 아키텍처

### 1. 스타일 파일 생성 원칙 (절대 규칙)
절대 원칙: 새로운 SCSS 파일을 생성하기 전에 반드시 다음 절차를 따릅니다.

[AI 실행 방안]:
- 스타일 수정 요청 시, 먼저 기존 파일 검색: "이미 'X' 기능을 위한 스타일 파일이 3개 존재합니다. 어떤 것을 수정할까요?"
- 새 파일 생성 시 5 Whys 분석: "왜 기존 파일을 수정하지 않고 새 파일이 필요한가요?"
- 중복 방지 체크리스트 자동 생성 및 확인

### 2. 디자인 토큰 우선 사용
원칙: 하드코딩된 값 대신 반드시 디자인 토큰을 사용합니다.

필수 사용 토큰:
- 색상: `design-tokens.scss`의 변수만 사용
- 간격: $spacing-xs ~ $spacing-2xl
- 폰트: $font-size-xs ~ $font-size-2xl
- 그림자: $shadow-sm ~ $shadow-2xl
- 반응형: 표준 브레이크포인트 믹스인 사용

[AI 실행 방안]:
- 하드코딩 감지 시 경고: "#1631F8 대신 $color-primary를 사용하세요"
- 픽셀 값 입력 시 토큰 자동 제안: "16px → $spacing-md"
- 커밋 전 하드코딩 검사 리포트 생성

### 3. 컴포넌트 기반 스타일링
원칙: 페이지별이 아닌 컴포넌트별로 스타일을 관리합니다.

구조:
```
components/
├── Button/
│   ├── Button.tsx
│   └── Button.module.scss
├── Card/
│   ├── Card.tsx
│   └── Card.module.scss
└── Layout/
    ├── Layout.tsx
    └── Layout.module.scss
```

[AI 실행 방안]:
- 페이지 레벨 스타일 생성 시 경고: "이 스타일은 Button 컴포넌트로 분리하는 것이 좋습니다"
- 자동 리팩토링 제안: "FeedbackButton 스타일을 Button 컴포넌트의 variant로 통합할까요?"

### 4. CSS 특정성 관리
원칙: !important 사용 금지, CSS 특정성으로 해결합니다.

해결 전략:
1. CSS 모듈 사용 (스타일 격리)
2. 더 구체적인 선택자 사용
3. 캐스케이드 순서 조정
4. CSS 변수로 동적 값 관리

[AI 실행 방안]:
- !important 감지 시 자동 대안 제시: "특정성을 높이려면 `.feedback-section .button` 사용"
- CSS 모듈 변환 자동화: "이 파일을 CSS 모듈로 변환하시겠습니까?"
- 특정성 계산기 제공: "현재 선택자의 특정성: 0-2-1"

### 5. 파일 명명 및 버전 관리
명명 규칙:
- 기능 중심: `Button.module.scss`, `Card.module.scss`
- Fix/Redesign 접미사 금지
- 버전은 Git으로 관리, 파일명에 포함 금지

[AI 실행 방안]:
- 잘못된 파일명 감지: "'ButtonFix.scss' → 'Button.module.scss'로 변경하세요"
- 기존 파일 수정 유도: "Button.scss가 이미 있습니다. 새 파일 대신 수정하시겠습니까?"

### 6. 리팩토링 시점 판단
리팩토링 트리거:
- 동일 기능 파일 3개 이상
- 하드코딩 값 10개 이상
- !important 5개 이상
- 중복 코드 30% 이상

[AI 실행 방안]:
- 자동 분석 리포트: "Button 관련 파일이 5개입니다. 통합이 필요합니다"
- 리팩토링 로드맵 생성: "1단계: 중복 제거, 2단계: 토큰 적용..."
- 영향 범위 분석: "이 변경은 15개 컴포넌트에 영향을 줍니다"

### 7. 코드 리뷰 체크리스트
필수 확인 사항:
- [ ] 기존 파일 수정 가능성 검토했는가?
- [ ] 디자인 토큰을 사용했는가?
- [ ] !important가 없는가?
- [ ] CSS 모듈을 사용했는가?
- [ ] 반응형 브레이크포인트가 통일되었는가?
- [ ] 접근성 스타일이 포함되었는가?

[AI 실행 방안]:
- PR 생성 시 자동 체크리스트 코멘트
- 위반 사항 하이라이트: "라인 23: 하드코딩된 색상 발견"
- 개선 제안 자동 생성

### 8. 단계적 마이그레이션 전략
원칙: 한 번에 모든 것을 바꾸지 않고, 점진적으로 개선합니다.

우선순위:
1. 사용 빈도 높은 컴포넌트부터
2. 중복이 심한 파일부터
3. !important가 많은 파일부터
4. 신규 기능은 처음부터 올바르게

[AI 실행 방안]:
- 마이그레이션 대상 자동 식별: "Button 스타일이 가장 많이 중복됩니다"
- 단계별 계획 수립: "1주차: Button 통합, 2주차: Layout 통합..."
- 진행 상황 추적: "전체 141개 중 23개 파일 정리 완료 (16%)"

---

**마지막 업데이트**: 2025-08-10
**버전**: 2.2.0